<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>EP2: linked_list.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">EP2</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">linked_list.h File Reference</div>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &lt;stdlib.h&gt;</code><br/>
</div>
<p><a href="linked__list_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlinked__list.html">linked_list</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A circular, doubly-linked list struct you can insert into your own structs, and therefore use with whatever type of data you want.  <a href="structlinked__list.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linked__list_8h.html#a0bdb7e96fe81ffea632ca9bdb4cfe8b1">linked_list_foreach</a>(iter, head, type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for iterating through a linked list.  <a href="#a0bdb7e96fe81ffea632ca9bdb4cfe8b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linked__list_8h.html#a52fd16782905e6f70034e0e460eb3476">linked_list_foreach_reverse</a>(iter, head, type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for iterating through a linked list in reverse.  <a href="#a52fd16782905e6f70034e0e460eb3476"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linked__list_8h.html#a5c18488c09abb69948b323d52a97b786">linked_list_foreach_safe</a>(iter, next, head, type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for iterating through a linked list allowing the removal of items.  <a href="#a5c18488c09abb69948b323d52a97b786"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linked__list_8h.html#adc03e16922ea53cd843596299dcc0292">linked_list_foreach_safe_reverse</a>(iter, next, head, type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for iterating through a linked list in reverse allowing the removal of items.  <a href="#adc03e16922ea53cd843596299dcc0292"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linked__list_8h.html#a5a1b20b69450930229925922f8bbfd4e">linked_list_free_items</a>(head, type, func)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Walks through a linked list destroying all it's items.  <a href="#a5a1b20b69450930229925922f8bbfd4e"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structlinked__list.html">linked_list</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linked__list_8h.html#a6d0b1eb6cc472bad39a1a957ef4ea3cb">linked_list</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A circular, doubly-linked list struct you can insert into your own structs, and therefore use with whatever type of data you want.  <a href="#a6d0b1eb6cc472bad39a1a957ef4ea3cb"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linked__list_8h.html#a31234c44f45a2cb8fd7e01130d9fb871">linked_list_init</a> (<a class="el" href="structlinked__list.html">linked_list</a> *head)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a linked list head for a circular list.  <a href="#a31234c44f45a2cb8fd7e01130d9fb871"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linked__list_8h.html#adbcc8eff472673fe2897cfc0baae7529">linked_list_front</a> (<a class="el" href="structlinked__list.html">linked_list</a> *head)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the front (first item after the head) of a linked list.  <a href="#adbcc8eff472673fe2897cfc0baae7529"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linked__list_8h.html#ad0183365a0a0bb3b47d6ab423aa201eb">linked_list_tail</a> (<a class="el" href="structlinked__list.html">linked_list</a> *head)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the tail (last item after the head) of a linked list.  <a href="#ad0183365a0a0bb3b47d6ab423aa201eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linked__list_8h.html#a9bcde1f65ad5d24cff1a79829bd4be28">linked_list_item_index</a> (<a class="el" href="structlinked__list.html">linked_list</a> *node, <a class="el" href="structlinked__list.html">linked_list</a> *head)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the numerical 0-based index of an item on a list.  <a href="#a9bcde1f65ad5d24cff1a79829bd4be28"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linked__list_8h.html#aaa2c466054b3f873ebac26036f18ea84">linked_list_empty</a> (<a class="el" href="structlinked__list.html">linked_list</a> *head)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a list is empty.  <a href="#aaa2c466054b3f873ebac26036f18ea84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linked__list_8h.html#aec9c0a73f27fe281e4ac1be8d894bb04">linked_list_length</a> (<a class="el" href="structlinked__list.html">linked_list</a> *head)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the number of items contained on a list.  <a href="#aec9c0a73f27fe281e4ac1be8d894bb04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linked__list_8h.html#abe4966716876506602a629961a2a06fe">linked_list_insert</a> (<a class="el" href="structlinked__list.html">linked_list</a> *node, <a class="el" href="structlinked__list.html">linked_list</a> *prev, <a class="el" href="structlinked__list.html">linked_list</a> *next)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an item between two existing items on a list.  <a href="#abe4966716876506602a629961a2a06fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linked__list_8h.html#a3b4895c1f0d9b22152c5d782e3ba6092">linked_list_remove</a> (<a class="el" href="structlinked__list.html">linked_list</a> *node)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an item from a linked list.  <a href="#a3b4895c1f0d9b22152c5d782e3ba6092"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linked__list_8h.html#a40e9d6253368c06688215e3bf6245fa2">linked_list_insert_after</a> (<a class="el" href="structlinked__list.html">linked_list</a> *node, <a class="el" href="structlinked__list.html">linked_list</a> *prev)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an item after an existing item on a list.  <a href="#a40e9d6253368c06688215e3bf6245fa2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linked__list_8h.html#af41d48716f7cee16dee6d0997ee3113d">linked_list_insert_before</a> (<a class="el" href="structlinked__list.html">linked_list</a> *node, <a class="el" href="structlinked__list.html">linked_list</a> *next)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an item before an existing item on a list.  <a href="#af41d48716f7cee16dee6d0997ee3113d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linked__list_8h.html#ace35a9c1a1ee6a9de65b753f3e3d909f">linked_list_push</a> (<a class="el" href="structlinked__list.html">linked_list</a> *node, <a class="el" href="structlinked__list.html">linked_list</a> *head)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an item after all existing items on a list.  <a href="#ace35a9c1a1ee6a9de65b753f3e3d909f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linked__list_8h.html#af7f5a40333915bc610936e5c1fc0d157">linked_list_push_front</a> (<a class="el" href="structlinked__list.html">linked_list</a> *node, <a class="el" href="structlinked__list.html">linked_list</a> *head)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an item before all existing items on a list.  <a href="#af7f5a40333915bc610936e5c1fc0d157"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linked__list_8h.html#a1e02163f9903a7f7c4cdd2dbe883ae1c">linked_list_pop</a> (<a class="el" href="structlinked__list.html">linked_list</a> *head)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last item after the head from the list and returns it.  <a href="#a1e02163f9903a7f7c4cdd2dbe883ae1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linked__list_8h.html#a7a492eed7c17b570c79285110bb6c8ab">linked_list_pop_front</a> (<a class="el" href="structlinked__list.html">linked_list</a> *head)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the first item after the head from the list and returns it.  <a href="#a7a492eed7c17b570c79285110bb6c8ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linked__list_8h.html#a5aeefcd1c4c6f183675d407ef9fb62f1">linked_list_swap</a> (<a class="el" href="structlinked__list.html">linked_list</a> *a, <a class="el" href="structlinked__list.html">linked_list</a> *b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the positions of two items on a list.  <a href="#a5aeefcd1c4c6f183675d407ef9fb62f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linked__list_8h.html#a5e9c79176144e2deebf99e79a79c9c04">linked_list_move_section_after</a> (<a class="el" href="structlinked__list.html">linked_list</a> *start, <a class="el" href="structlinked__list.html">linked_list</a> *end, <a class="el" href="structlinked__list.html">linked_list</a> *pos)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves a section of the list to a different position.  <a href="#a5e9c79176144e2deebf99e79a79c9c04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaabb7cbeaba8f440541e1ad0e11cfb8e"></a><!-- doxytag: member="linked_list.h::linked_list_merge_sorted_find_upper__" ref="aaabb7cbeaba8f440541e1ad0e11cfb8e" args="(linked_list *start, linked_list *end, int(*comparator)(const void *, const void *), const void *pivot)" -->
static <a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>linked_list_merge_sorted_find_upper__</b> (<a class="el" href="structlinked__list.html">linked_list</a> *start, <a class="el" href="structlinked__list.html">linked_list</a> *end, int(*comparator)(const void *, const void *), const void *pivot)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linked__list_8h.html#a2f26a0afcf250c19c3073f7bafb0bcd9">linked_list_merge_sorted_sections</a> (<a class="el" href="structlinked__list.html">linked_list</a> **half1_start, <a class="el" href="structlinked__list.html">linked_list</a> *half1_end, <a class="el" href="structlinked__list.html">linked_list</a> *half2_start, <a class="el" href="structlinked__list.html">linked_list</a> *half2_end, int(*comparator)(const void *, const void *))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges a section of a sorted list into another section of a sorted list, inserting elements at their proper sorted positions.  <a href="#a2f26a0afcf250c19c3073f7bafb0bcd9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linked__list_8h.html#aa8748022fbf249379e508bec07f314cd">linked_list_merge_sorted</a> (<a class="el" href="structlinked__list.html">linked_list</a> *head1, <a class="el" href="structlinked__list.html">linked_list</a> *head2, int(*comparator)(const void *, const void *))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges a sorted list into another sorted list, inserting elements at their proper sorted positions.  <a href="#aa8748022fbf249379e508bec07f314cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="accbcfe2317a94031910d7ab0453d3160"></a><!-- doxytag: member="linked_list.h::linked_list_merge_sort__" ref="accbcfe2317a94031910d7ab0453d3160" args="(linked_list **start, linked_list *end, int(*comparator)(const void *, const void *))" -->
static void&#160;</td><td class="memItemRight" valign="bottom"><b>linked_list_merge_sort__</b> (<a class="el" href="structlinked__list.html">linked_list</a> **start, <a class="el" href="structlinked__list.html">linked_list</a> *end, int(*comparator)(const void *, const void *))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linked__list_8h.html#ab465e6005c42609d6ea8dd89fe286a58">linked_list_sort_section</a> (<a class="el" href="structlinked__list.html">linked_list</a> **start, <a class="el" href="structlinked__list.html">linked_list</a> *end, int(*comparator)(const void *, const void *))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts a section of a list according to a comparator function.  <a href="#ab465e6005c42609d6ea8dd89fe286a58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linked__list_8h.html#ae2221da54942b148ac442f60c594c7dc">linked_list_sort</a> (<a class="el" href="structlinked__list.html">linked_list</a> *head, int(*comparator)(const void *, const void *))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts a list according to a comparator function.  <a href="#ae2221da54942b148ac442f60c594c7dc"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A circular, doubly-linked list datatype implementation you can include in other structs for use with any kind of data.</p>
<p>Functions for initialization, search, insertion, removal and sorting of items are included, along with macros for iteration.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>Daniel Miranda</dd></dl>
<p>Copyright (c) 2011 Daniel Miranda. All Rights Reserved. Licensed under the GNU General Public License, version 2. </p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a0bdb7e96fe81ffea632ca9bdb4cfe8b1"></a><!-- doxytag: member="linked_list.h::linked_list_foreach" ref="a0bdb7e96fe81ffea632ca9bdb4cfe8b1" args="(iter, head, type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define linked_list_foreach</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iter, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">head, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">for</span>(iter = (type*)((head)-&gt;<a class="code" href="structlinked__list.html#af26edbe8295d8a630ae63411d5d4f3ff" title="Pointer to the next item on the list.">next</a>); \
        iter != NULL &amp;&amp; iter != (type*)(head); \
        iter = (type*)(((<a class="code" href="structlinked__list.html" title="A circular, doubly-linked list struct you can insert into your own structs, and therefore use with wh...">linked_list</a>*)iter)-&gt;next) \
    )
</pre></div>
<p>Macro for iterating through a linked list. </p>
<p>Use it where you would include a for loop, following it with an opening bracket, your code, and a matching closing bracket.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>It is not safe to remove items from the list using this macro. Use linked_list_foreach_safe instead if you want to do that.</dd></dl>
<p>Example of use:</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
     <a class="code" href="structlinked__list.html" title="A circular, doubly-linked list struct you can insert into your own structs, and therefore use with wh...">linked_list</a> list;
     <span class="keywordtype">int</span> my_number;
 } my_data;
  
 my_data head, *iter;
 <span class="keywordtype">size_t</span> i;

 <a class="code" href="linked__list_8h.html#a31234c44f45a2cb8fd7e01130d9fb871" title="Initializes a linked list head for a circular list.">linked_list_init</a>(&amp;head.list);

 <span class="keywordflow">for</span>(i = 0; i &lt; 100; i++) {
     my_data* data = (my_data*)malloc(<span class="keyword">sizeof</span> *data);
     <span class="keywordflow">if</span>(data != NULL) {
         data-&gt;my_number = i;
         <a class="code" href="linked__list_8h.html#ace35a9c1a1ee6a9de65b753f3e3d909f" title="Inserts an item after all existing items on a list.">linked_list_push</a>(&amp;(data-&gt;list), &amp;(head.list));
     }
 }

 <a class="code" href="linked__list_8h.html#a0bdb7e96fe81ffea632ca9bdb4cfe8b1" title="Macro for iterating through a linked list.">linked_list_foreach</a>(iter, &amp;(head.list), my_data) {
     printf(<span class="stringliteral">&quot;%d\n&quot;</span>, iter-&gt;my_number);
 }
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>A variable of the same type as the struct containing the <a class="el" href="structlinked__list.html" title="A circular, doubly-linked list struct you can insert into your own structs, and therefore use with wh...">linked_list</a>, that will be the iterator. It will contain a pointer to the current list item at each iteration. </td></tr>
    <tr><td class="paramname">head</td><td>Pointer to the head of the list </td></tr>
    <tr><td class="paramname">type</td><td>Type of the struct where the <a class="el" href="structlinked__list.html" title="A circular, doubly-linked list struct you can insert into your own structs, and therefore use with wh...">linked_list</a> is contained</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="linked__list_8h.html#a5c18488c09abb69948b323d52a97b786" title="Macro for iterating through a linked list allowing the removal of items.">linked_list_foreach_safe</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a52fd16782905e6f70034e0e460eb3476"></a><!-- doxytag: member="linked_list.h::linked_list_foreach_reverse" ref="a52fd16782905e6f70034e0e460eb3476" args="(iter, head, type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define linked_list_foreach_reverse</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iter, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">head, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">for</span>(iter = (type*)((head)-&gt;prev); \
        iter != NULL &amp;&amp; iter != (type*)(head); \
        iter = (type*)(((<a class="code" href="structlinked__list.html" title="A circular, doubly-linked list struct you can insert into your own structs, and therefore use with wh...">linked_list</a>*)iter)-&gt;prev) \
    )
</pre></div>
<p>Macro for iterating through a linked list in reverse. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>It is not safe to remove items from the list using this macro. Use linked_list_foreach_safe_reverse instead if you want to do that.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>A variable of the same type as the struct containing the <a class="el" href="structlinked__list.html" title="A circular, doubly-linked list struct you can insert into your own structs, and therefore use with wh...">linked_list</a>, that will be the iterator. It will contain a pointer to the current list item at each iteration. </td></tr>
    <tr><td class="paramname">head</td><td>Pointer to the head of the list </td></tr>
    <tr><td class="paramname">type</td><td>Type of the struct where the <a class="el" href="structlinked__list.html" title="A circular, doubly-linked list struct you can insert into your own structs, and therefore use with wh...">linked_list</a> is contained</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="linked__list_8h.html#a0bdb7e96fe81ffea632ca9bdb4cfe8b1" title="Macro for iterating through a linked list.">linked_list_foreach</a> </dd>
<dd>
<a class="el" href="linked__list_8h.html#adc03e16922ea53cd843596299dcc0292" title="Macro for iterating through a linked list in reverse allowing the removal of items.">linked_list_foreach_safe_reverse</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5c18488c09abb69948b323d52a97b786"></a><!-- doxytag: member="linked_list.h::linked_list_foreach_safe" ref="a5c18488c09abb69948b323d52a97b786" args="(iter, next, head, type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define linked_list_foreach_safe</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iter, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">next, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">head, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">for</span>(iter = (type*)((head)-&gt;next), \
        next = (type*)(((<a class="code" href="structlinked__list.html" title="A circular, doubly-linked list struct you can insert into your own structs, and therefore use with wh...">linked_list</a>*)iter)-&gt;next); \
        \
        iter != NULL &amp;&amp; iter != (type*)(head); \
        \
        iter = next, next = (type*)(((<a class="code" href="structlinked__list.html" title="A circular, doubly-linked list struct you can insert into your own structs, and therefore use with wh...">linked_list</a>*)iter)-&gt;next) \
    )
</pre></div>
<p>Macro for iterating through a linked list allowing the removal of items. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>A variable of the same type as the struct containing the <a class="el" href="structlinked__list.html" title="A circular, doubly-linked list struct you can insert into your own structs, and therefore use with wh...">linked_list</a>, that will be the iterator. It will contain a pointer to the current list item at each iteration </td></tr>
    <tr><td class="paramname">next</td><td>Another variable to use as a temporary iterator </td></tr>
    <tr><td class="paramname">head</td><td>Pointer to the head of the list </td></tr>
    <tr><td class="paramname">type</td><td>Type of the struct where the <a class="el" href="structlinked__list.html" title="A circular, doubly-linked list struct you can insert into your own structs, and therefore use with wh...">linked_list</a> is contained</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="linked__list_8h.html#a0bdb7e96fe81ffea632ca9bdb4cfe8b1" title="Macro for iterating through a linked list.">linked_list_foreach</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adc03e16922ea53cd843596299dcc0292"></a><!-- doxytag: member="linked_list.h::linked_list_foreach_safe_reverse" ref="adc03e16922ea53cd843596299dcc0292" args="(iter, next, head, type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define linked_list_foreach_safe_reverse</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iter, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">next, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">head, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">for</span>(iter = (type*)((head)-&gt;prev), \
        next = (type*)(((<a class="code" href="structlinked__list.html" title="A circular, doubly-linked list struct you can insert into your own structs, and therefore use with wh...">linked_list</a>*)iter)-&gt;prev); \
        \
        iter != NULL &amp;&amp; iter != (type*)(head); \
        \
        iter = next, next = (type*)(((<a class="code" href="structlinked__list.html" title="A circular, doubly-linked list struct you can insert into your own structs, and therefore use with wh...">linked_list</a>*)iter)-&gt;prev) \
    )
</pre></div>
<p>Macro for iterating through a linked list in reverse allowing the removal of items. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>A variable of the same type as the struct containing the <a class="el" href="structlinked__list.html" title="A circular, doubly-linked list struct you can insert into your own structs, and therefore use with wh...">linked_list</a>, that will be the iterator. It will contain a pointer to the current list item at each iteration </td></tr>
    <tr><td class="paramname">next</td><td>Another variable to use as a temporary iterator </td></tr>
    <tr><td class="paramname">head</td><td>Pointer to the head of the list </td></tr>
    <tr><td class="paramname">type</td><td>Type of the struct where the <a class="el" href="structlinked__list.html" title="A circular, doubly-linked list struct you can insert into your own structs, and therefore use with wh...">linked_list</a> is contained</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="linked__list_8h.html#a0bdb7e96fe81ffea632ca9bdb4cfe8b1" title="Macro for iterating through a linked list.">linked_list_foreach</a> </dd>
<dd>
<a class="el" href="linked__list_8h.html#a5c18488c09abb69948b323d52a97b786" title="Macro for iterating through a linked list allowing the removal of items.">linked_list_foreach_safe</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5a1b20b69450930229925922f8bbfd4e"></a><!-- doxytag: member="linked_list.h::linked_list_free_items" ref="a5a1b20b69450930229925922f8bbfd4e" args="(head, type, func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define linked_list_free_items</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">head, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">func&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{ \
        type *iter, *next; \
        <span class="keywordflow">for</span>(iter = (type*)((head)-&gt;next), \
            next = (type*)(((<a class="code" href="structlinked__list.html" title="A circular, doubly-linked list struct you can insert into your own structs, and therefore use with wh...">linked_list</a>*)iter)-&gt;next); \
            \
            iter != NULL &amp;&amp; iter != (type*)(head); \
            \
            iter = next, next = (type*)(((<a class="code" href="structlinked__list.html" title="A circular, doubly-linked list struct you can insert into your own structs, and therefore use with wh...">linked_list</a>*)iter)-&gt;next) \
        ) { \
            func(iter); \
        } \
        <a class="code" href="linked__list_8h.html#a31234c44f45a2cb8fd7e01130d9fb871" title="Initializes a linked list head for a circular list.">linked_list_init</a>(head); \
    }
</pre></div>
<p>Walks through a linked list destroying all it's items. </p>
<p>If you allocated the head in the heap, you should also free it yourself.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of the list </td></tr>
    <tr><td class="paramname">type</td><td>Type of the struct where the <a class="el" href="structlinked__list.html" title="A circular, doubly-linked list struct you can insert into your own structs, and therefore use with wh...">linked_list</a> is contained </td></tr>
    <tr><td class="paramname">func</td><td>Name of a function that will be called to cleanup each item. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a6d0b1eb6cc472bad39a1a957ef4ea3cb"></a><!-- doxytag: member="linked_list.h::linked_list" ref="a6d0b1eb6cc472bad39a1a957ef4ea3cb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlinked__list.html">linked_list</a>  <a class="el" href="structlinked__list.html">linked_list</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A circular, doubly-linked list struct you can insert into your own structs, and therefore use with whatever type of data you want. </p>
<p>Initialize the head with <a class="el" href="linked__list_8h.html#a31234c44f45a2cb8fd7e01130d9fb871" title="Initializes a linked list head for a circular list.">linked_list_init()</a></p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>It <em>must</em> be the first element of its containing struct. </dd></dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aaa2c466054b3f873ebac26036f18ea84"></a><!-- doxytag: member="linked_list.h::linked_list_empty" ref="aaa2c466054b3f873ebac26036f18ea84" args="(linked_list *head)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int linked_list_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines if a list is empty. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of a linked list</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the list has no items, 0 otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="adbcc8eff472673fe2897cfc0baae7529"></a><!-- doxytag: member="linked_list.h::linked_list_front" ref="adbcc8eff472673fe2897cfc0baae7529" args="(linked_list *head)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structlinked__list.html">linked_list</a>* linked_list_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds the front (first item after the head) of a linked list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of a linked list</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the front item or a null pointer on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a31234c44f45a2cb8fd7e01130d9fb871"></a><!-- doxytag: member="linked_list.h::linked_list_init" ref="a31234c44f45a2cb8fd7e01130d9fb871" args="(linked_list *head)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void linked_list_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes a linked list head for a circular list. </p>
<p>The head will then point to itself.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head to initalize </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abe4966716876506602a629961a2a06fe"></a><!-- doxytag: member="linked_list.h::linked_list_insert" ref="abe4966716876506602a629961a2a06fe" args="(linked_list *node, linked_list *prev, linked_list *next)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void linked_list_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td>
          <td class="paramname"><em>prev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td>
          <td class="paramname"><em>next</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inserts an item between two existing items on a list. </p>
<p>If the two items do not directly follow each other, other items between them will possibly leak. Be sure to take care of them if that's what is actually intended.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Pointer to the item to insert </td></tr>
    <tr><td class="paramname">prev</td><td>Pointer to the item that will precede the inserted item on the list order </td></tr>
    <tr><td class="paramname">next</td><td>Pointer to the item that will follow the inserted item on the list order </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a40e9d6253368c06688215e3bf6245fa2"></a><!-- doxytag: member="linked_list.h::linked_list_insert_after" ref="a40e9d6253368c06688215e3bf6245fa2" args="(linked_list *node, linked_list *prev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void linked_list_insert_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td>
          <td class="paramname"><em>prev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inserts an item after an existing item on a list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Pointer to the item to insert </td></tr>
    <tr><td class="paramname">prev</td><td>Pointer to the item that will precede the inserted item on the list order </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af41d48716f7cee16dee6d0997ee3113d"></a><!-- doxytag: member="linked_list.h::linked_list_insert_before" ref="af41d48716f7cee16dee6d0997ee3113d" args="(linked_list *node, linked_list *next)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void linked_list_insert_before </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td>
          <td class="paramname"><em>next</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inserts an item before an existing item on a list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Pointer to the item to insert </td></tr>
    <tr><td class="paramname">next</td><td>Pointer to the item that will follow the inserted item on the list order </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9bcde1f65ad5d24cff1a79829bd4be28"></a><!-- doxytag: member="linked_list.h::linked_list_item_index" ref="a9bcde1f65ad5d24cff1a79829bd4be28" args="(linked_list *node, linked_list *head)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static size_t linked_list_item_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td>
          <td class="paramname"><em>head</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the numerical 0-based index of an item on a list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of the list </td></tr>
    <tr><td class="paramname">node</td><td>Pointer to the item whose index is to be retrieved</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The numerical index, or 0 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="aec9c0a73f27fe281e4ac1be8d894bb04"></a><!-- doxytag: member="linked_list.h::linked_list_length" ref="aec9c0a73f27fe281e4ac1be8d894bb04" args="(linked_list *head)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static size_t linked_list_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines the number of items contained on a list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of a linked list</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Count of items in the list, or 0 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="aa8748022fbf249379e508bec07f314cd"></a><!-- doxytag: member="linked_list.h::linked_list_merge_sorted" ref="aa8748022fbf249379e508bec07f314cd" args="(linked_list *head1, linked_list *head2, int(*comparator)(const void *, const void *))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void linked_list_merge_sorted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td>
          <td class="paramname"><em>head1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td>
          <td class="paramname"><em>head2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>comparator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Merges a sorted list into another sorted list, inserting elements at their proper sorted positions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">head1</td><td>Pointer to the head of a sorted list onto which the second list's items will be inserted </td></tr>
    <tr><td class="paramname">head2</td><td>Pointer to the head of a second sorted list which will have it's elements extracted then inserted into the first list </td></tr>
    <tr><td class="paramname">comparator</td><td>Pointer to a comparator function, which determines the ordering of items </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2f26a0afcf250c19c3073f7bafb0bcd9"></a><!-- doxytag: member="linked_list.h::linked_list_merge_sorted_sections" ref="a2f26a0afcf250c19c3073f7bafb0bcd9" args="(linked_list **half1_start, linked_list *half1_end, linked_list *half2_start, linked_list *half2_end, int(*comparator)(const void *, const void *))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void linked_list_merge_sorted_sections </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlinked__list.html">linked_list</a> **&#160;</td>
          <td class="paramname"><em>half1_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td>
          <td class="paramname"><em>half1_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td>
          <td class="paramname"><em>half2_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td>
          <td class="paramname"><em>half2_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>comparator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Merges a section of a sorted list into another section of a sorted list, inserting elements at their proper sorted positions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">half1_start</td><td>Pointer to pointer to the first item (<em>not the head</em>) of a sorted list on which the second list's items will be inserted. Since the first item may change with the sorting, it will be updated accordingly </td></tr>
    <tr><td class="paramname">half1_end</td><td>Pointer to one item <em>past</em> the end of the first list </td></tr>
    <tr><td class="paramname">half2_start</td><td>Pointer to the first item (<em>not the head</em>) of a second sorted list which will have it's elements extracted then inserted into the first list </td></tr>
    <tr><td class="paramname">half2_end</td><td>Pointer to one item <em>past</em> the end of the second list </td></tr>
    <tr><td class="paramname">comparator</td><td>Pointer to a comparator function, which determines the ordering of items </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e9c79176144e2deebf99e79a79c9c04"></a><!-- doxytag: member="linked_list.h::linked_list_move_section_after" ref="a5e9c79176144e2deebf99e79a79c9c04" args="(linked_list *start, linked_list *end, linked_list *pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void linked_list_move_section_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves a section of the list to a different position. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Pointer to the first item (<em>not the head</em>) of the section to be moved </td></tr>
    <tr><td class="paramname">end</td><td>Pointer to the item <em>past</em> the last item to be moved </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to the item that will precede the inserted section on the new list ordering. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1e02163f9903a7f7c4cdd2dbe883ae1c"></a><!-- doxytag: member="linked_list.h::linked_list_pop" ref="a1e02163f9903a7f7c4cdd2dbe883ae1c" args="(linked_list *head)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structlinked__list.html">linked_list</a>* linked_list_pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the last item after the head from the list and returns it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of the list</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the removed item or a null pointer on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a7a492eed7c17b570c79285110bb6c8ab"></a><!-- doxytag: member="linked_list.h::linked_list_pop_front" ref="a7a492eed7c17b570c79285110bb6c8ab" args="(linked_list *head)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structlinked__list.html">linked_list</a>* linked_list_pop_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the first item after the head from the list and returns it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of the list</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the removed item or a null pointer on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ace35a9c1a1ee6a9de65b753f3e3d909f"></a><!-- doxytag: member="linked_list.h::linked_list_push" ref="ace35a9c1a1ee6a9de65b753f3e3d909f" args="(linked_list *node, linked_list *head)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void linked_list_push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td>
          <td class="paramname"><em>head</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inserts an item after all existing items on a list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Pointer to the item to insert </td></tr>
    <tr><td class="paramname">head</td><td>Pointer to the head of the list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af7f5a40333915bc610936e5c1fc0d157"></a><!-- doxytag: member="linked_list.h::linked_list_push_front" ref="af7f5a40333915bc610936e5c1fc0d157" args="(linked_list *node, linked_list *head)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void linked_list_push_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td>
          <td class="paramname"><em>head</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inserts an item before all existing items on a list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Pointer to the item to insert </td></tr>
    <tr><td class="paramname">head</td><td>Pointer to the head of the list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3b4895c1f0d9b22152c5d782e3ba6092"></a><!-- doxytag: member="linked_list.h::linked_list_remove" ref="a3b4895c1f0d9b22152c5d782e3ba6092" args="(linked_list *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structlinked__list.html">linked_list</a>* linked_list_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes an item from a linked list. </p>
<p>Removing the head is an invalid operation, no guarantees are made if you pass it to this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Pointer to the item to remove</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the removed item or a null pointer on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ae2221da54942b148ac442f60c594c7dc"></a><!-- doxytag: member="linked_list.h::linked_list_sort" ref="ae2221da54942b148ac442f60c594c7dc" args="(linked_list *head, int(*comparator)(const void *, const void *))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void linked_list_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>comparator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sorts a list according to a comparator function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of the list </td></tr>
    <tr><td class="paramname">comparator</td><td>Pointer to a comparator function, which determines the ordering of items </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab465e6005c42609d6ea8dd89fe286a58"></a><!-- doxytag: member="linked_list.h::linked_list_sort_section" ref="ab465e6005c42609d6ea8dd89fe286a58" args="(linked_list **start, linked_list *end, int(*comparator)(const void *, const void *))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void linked_list_sort_section </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlinked__list.html">linked_list</a> **&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>comparator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sorts a section of a list according to a comparator function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Pointer to pointer to the first item (<em>not the head</em>) of the section. Since the start may change with the sorting, it will be updated accordingly </td></tr>
    <tr><td class="paramname">end</td><td>Pointer to the item <em>past</em> the last item of the section </td></tr>
    <tr><td class="paramname">comparator</td><td>Pointer to a comparator function, which determines the ordering of items </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5aeefcd1c4c6f183675d407ef9fb62f1"></a><!-- doxytag: member="linked_list.h::linked_list_swap" ref="a5aeefcd1c4c6f183675d407ef9fb62f1" args="(linked_list *a, linked_list *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void linked_list_swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swaps the positions of two items on a list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Item to swap </td></tr>
    <tr><td class="paramname">b</td><td>Other item to swap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad0183365a0a0bb3b47d6ab423aa201eb"></a><!-- doxytag: member="linked_list.h::linked_list_tail" ref="ad0183365a0a0bb3b47d6ab423aa201eb" args="(linked_list *head)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structlinked__list.html">linked_list</a>* linked_list_tail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlinked__list.html">linked_list</a> *&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds the tail (last item after the head) of a linked list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of a linked list</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the tail item or a null pointer on failure </dd></dl>

</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Fri Sep 9 2011 06:46:41 for EP2 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
